import os
import cv2
import numpy as np
import sys

def organize_and_resize_with_face_detection(image_dir, identity_file, output_dir, target_size=(112, 112), use_transparent_bg=False):
    """
    顔検出を利用してデータセットをクラスごとに整理し、顔領域のみリサイズして保存する。
    処理の進捗を分数およびパーセンテージで表示し、顔が検出できなかった画像をカウントします。
    :param image_dir: 元の画像フォルダ
    :param identity_file: ID情報が記載されたファイル
    :param output_dir: クラスごとに整理してリサイズした画像の保存先
    :param target_size: リサイズ後の画像サイズ (width, height)
    :param use_transparent_bg: Trueの場合、余白を透過にします
    """
    # OpenCVのDNNモジュールを使用して顔検出モデルを読み込む
    cascades_dir = os.path.join(os.path.dirname(__file__), "data", "cascades")
    model_file = os.path.join(cascades_dir, "deploy.prototxt")
    weights_file = os.path.join(cascades_dir, "res10_300x300_ssd_iter_140000.caffemodel")
    net = cv2.dnn.readNetFromCaffe(model_file, weights_file)

    # 出力ディレクトリを作成
    os.makedirs(output_dir, exist_ok=True)

    # ID情報ファイルを読み込み
    with open(identity_file, 'r') as f:
        lines = f.readlines()

    total_images = len(lines)  # 全画像数
    no_face_count = 0  # 顔が検出できなかった画像数

    for idx, line in enumerate(lines, start=1):
        # ファイル名とクラスIDを取得
        image_name, person_id = line.strip().split()

        # 元画像のパス
        input_image_path = os.path.join(image_dir, image_name)
        if not os.path.exists(input_image_path):
            print(f"Warning: Image not found: {input_image_path}")
            continue

        # 出力先のクラスフォルダを作成
        person_folder = os.path.join(output_dir, f'class_{person_id}')
        os.makedirs(person_folder, exist_ok=True)

        # 元画像を読み込み
        img = cv2.imread(input_image_path)
        if img is None:
            print(f"Warning: Failed to read image: {input_image_path}")
            continue

        # 顔検出
        (h, w) = img.shape[:2]
        blob = cv2.dnn.blobFromImage(cv2.resize(img, (300, 300)), 1.0, (300, 300), (104.0, 177.0, 123.0))
        net.setInput(blob)
        detections = net.forward()

        # 最大の顔領域を探す
        max_area = 0
        face_box = None
        for i in range(detections.shape[2]):
            confidence = detections[0, 0, i, 2]
            if confidence > 0.5:  # 信頼度が50%以上の顔を使用
                box = detections[0, 0, i, 3:7] * np.array([w, h, w, h])
                (x1, y1, x2, y2) = box.astype("int")
                area = (x2 - x1) * (y2 - y1)
                if area > max_area:
                    max_area = area
                    face_box = (x1, y1, x2, y2)

        # 顔が検出された場合はクロップ、検出されない場合は元画像を使用
        if face_box is not None:
            (x1, y1, x2, y2) = face_box
            cropped_img = img[max(0, y1):min(h, y2), max(0, x1):min(w, x2)]  # 顔領域をクロップ
        else:
            no_face_count += 1
            cropped_img = img

        # リサイズ（アスペクト比を維持、余白を設定）
        resized_img = resize_with_aspect_ratio(cropped_img, target_size, use_transparent_bg)

        # 保存先のパス
        output_image_path = os.path.join(person_folder, image_name)
        cv2.imwrite(output_image_path, resized_img)

        # 進捗表示（上書き）
        progress = f"Processing: {idx}/{total_images} ({(idx / total_images) * 100:.2f}%) - No Face: {no_face_count}"
        sys.stdout.write(f"\r{progress}")
        sys.stdout.flush()

    print(f"\nOrganized and resized dataset saved to: {output_dir}")
    print(f"Total images processed: {total_images}, No face detected: {no_face_count}")


def resize_with_aspect_ratio(image, target_size, use_transparent_bg=False):
    """
    アスペクト比を維持して画像をリサイズし、余白を追加。
    :param image: 入力画像
    :param target_size: リサイズ後のサイズ (width, height)
    :param use_transparent_bg: Trueの場合、余白を透過にします
    :return: リサイズされた画像
    """
    target_width, target_height = target_size
    h, w = image.shape[:2]

    # アスペクト比を計算
    aspect_ratio = w / h
    if w > h:
        new_width = target_width
        new_height = int(new_width / aspect_ratio)
    else:
        new_height = target_height
        new_width = int(new_height * aspect_ratio)

    resized_img = cv2.resize(image, (new_width, new_height))

    # ターゲットサイズのキャンバスを作成して中央に配置
    if use_transparent_bg:
        canvas = np.zeros((target_height, target_width, 4), dtype="uint8")  # 透過用アルファチャネル付き
    else:
        canvas = np.zeros((target_height, target_width, 3), dtype="uint8")  # 黒背景

    x_offset = (target_width - new_width) // 2
    y_offset = (target_height - new_height) // 2
    canvas[y_offset:y_offset + new_height, x_offset:x_offset + new_width] = resized_img

    return canvas


# --- 実行 ---
if __name__ == "__main__":
    # 現在のスクリプトディレクトリを基準とする
    base_dir = os.path.dirname(os.path.abspath(__file__))

    # パス指定（相対パス）
    image_dir = os.path.join(base_dir, "data/img_align_celeba")  # 元画像フォルダ
    identity_file = os.path.join(base_dir, "data/identity_CelebA_png.txt")  # PNG形式に変換されたID情報ファイル
    output_dir = os.path.join(base_dir, "processed_data")  # 出力フォルダ

    # 処理を実行
    organize_and_resize_with_face_detection(
        image_dir,
        identity_file,
        output_dir,
        target_size=(112, 112),
        use_transparent_bg=True  # Trueにすると余白が透過になります
    )
