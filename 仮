import os
import cv2
import psutil
import threading
import time
import pandas as pd
import sys

# メモリ使用量を動的に表示する関数
def monitor_memory(interval=1):
    """
    メモリ使用量を動的に表示する。
    :param interval: メモリ使用量を表示する間隔（秒単位）
    """
    while True:
        memory = psutil.virtual_memory()
        message = (f"\r[Memory Monitor] Total: {memory.total // (1024**3)} GB | "
                   f"Used: {memory.used // (1024**3)} GB | "
                   f"Available: {memory.available // (1024**3)} GB | "
                   f"Usage: {memory.percent}%")
        sys.stdout.write(message)
        sys.stdout.flush()
        time.sleep(interval)

# データセットを整理＆リサイズする関数
def organize_and_resize_dataset(image_dir, identity_file, bbox_file, output_dir, target_size=(112, 112), batch_size=100):
    os.makedirs(output_dir, exist_ok=True)
    with open(identity_file, 'r') as f:
        lines = f.readlines()
    bbox_data = pd.read_csv(bbox_file, delim_whitespace=True, skiprows=1)

    for batch_start in range(0, len(lines), batch_size):
        batch = lines[batch_start:batch_start + batch_size]
        for line in batch:
            image_name, person_id = line.strip().split()
            person_folder = os.path.join(output_dir, f'class_{person_id}')
            os.makedirs(person_folder, exist_ok=True)

            input_image_path = os.path.join(image_dir, image_name)
            if not os.path.exists(input_image_path):
                print(f"Warning: Image not found: {input_image_path}")
                continue

            bbox_row = bbox_data[bbox_data['image_id'] == image_name]
            if bbox_row.empty:
                print(f"Warning: No bounding box found for {image_name}")
                continue
            x, y, w, h = bbox_row.iloc[0][['x_1', 'y_1', 'width', 'height']]

            try:
                img = cv2.imread(input_image_path)
                if img is None:
                    raise ValueError(f"Failed to read image: {input_image_path}")
                cropped_img = img[int(y):int(y + h), int(x):int(x + w)]
                resized_img = cv2.resize(cropped_img, target_size)
                output_image_path = os.path.join(person_folder, image_name)
                cv2.imwrite(output_image_path, resized_img)
            except Exception as e:
                print(f"Error processing image {image_name}: {e}")

        print(f"\nProcessed batch {batch_start // batch_size + 1} of {len(lines) // batch_size + 1}")
    print(f"\nOrganized and resized dataset saved to: {output_dir}")


# --- 実行 ---
if __name__ == "__main__":
    memory_thread = threading.Thread(target=monitor_memory, args=(1,), daemon=True)
    memory_thread.start()

    base_dir = os.path.dirname(os.path.abspath(__file__))
    image_dir = os.path.join(base_dir, "data/img_align_celeba")
    identity_file = os.path.join(base_dir, "data/identity_CelebA.txt")
    bbox_file = os.path.join(base_dir, "data/list_bbox_celeba.txt")
    output_dir = os.path.join(base_dir, "processed_data")

    organize_and_resize_dataset(image_dir, identity_file, bbox_file, output_dir, target_size=(112, 112), batch_size=100)
