import os
import sys
import time  # クラスごとの処理時間を計測
import cv2
import numpy as np
import insightface
from tqdm import tqdm  # 進捗バーライブラリ
from sklearn.model_selection import train_test_split, KFold
from tensorflow.keras.applications import EfficientNetB0
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Dense, Dropout, Input, Concatenate, Attention, GlobalAveragePooling2D
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.utils import to_categorical
from tensorflow.keras.callbacks import EarlyStopping, ReduceLROnPlateau
import tensorflow as tf  # TensorFlowインポート
from tensorflow.keras.regularizers import l2  # L2正則化を追加

# ---------------------------------------------
# パス設定と初期化
# ---------------------------------------------
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DATASET_DIR = os.path.join(BASE_DIR, "processed_data")  # 学習データフォルダ
EMBEDDING_DIR = os.path.join(BASE_DIR, "embeddings")  # 埋め込みベクトル保存フォルダ
MODEL_DIR = os.path.join(BASE_DIR, "model")  # 学習済みモデル保存フォルダ
NO_FACE_DIR = os.path.join(BASE_DIR, "unnecessary_file/no_face_detected")  # 顔が検出できなかった画像の保存先

if not os.path.exists(EMBEDDING_DIR):
    os.makedirs(EMBEDDING_DIR)
if not os.path.exists(MODEL_DIR):
    os.makedirs(MODEL_DIR)
if not os.path.exists(NO_FACE_DIR):
    os.makedirs(NO_FACE_DIR)

# ---------------------------------------------
# ArcFaceモデルとEfficientNetB0の準備
# ---------------------------------------------
print("Loading ArcFace model...")
try:
    app = insightface.app.FaceAnalysis(name='buffalo_l')  # ArcFaceモデル
    app.prepare(ctx_id=0, det_size=(224, 224))  # GPUを使用（ctx_id=0）
except Exception as e:
    print("GPU not available, switching to CPU...")
    app = insightface.app.FaceAnalysis(name='buffalo_l')
    app.prepare(ctx_id=-1, det_size=(224, 224))  # CPUを使用（ctx_id=-1）

print("Loading EfficientNetB0 model for feature extraction...")
base_efficientnet = EfficientNetB0(weights='imagenet', include_top=False, input_shape=(224, 224, 3))

# Fine-Tuning: EfficientNetB0の最後の20層を学習可能に
for layer in base_efficientnet.layers[:-20]:
    layer.trainable = False
for layer in base_efficientnet.layers[-20:]:
    layer.trainable = True

x = base_efficientnet.output
efficientnet_output = GlobalAveragePooling2D()(x)
fine_tuned_efficientnet = Model(inputs=base_efficientnet.input, outputs=efficientnet_output)

# ---------------------------------------------
# 学習可能なDense層の事前定義
# ---------------------------------------------
arcface_dense_layer = Dense(256, activation='relu', name="arcface_dense")

# ---------------------------------------------
# 顔埋め込みベクトルの抽出
# ---------------------------------------------
def extract_face_embeddings(image_path):
    """
    ArcFaceとEfficientNetB0を使用して画像から埋め込みベクトルを取得する。
    エラー時にはゼロ埋めで安全に処理する。
    :param image_path: 画像のパス
    :return: (ArcFace埋め込みベクトル, EfficientNetB0埋め込みベクトル)
    """
    img = cv2.imread(image_path)
    if img is None:
        print(f"Warning: Unable to load image {image_path}")
        return np.zeros(512), np.zeros(1280), None  # ArcFaceとEfficientNetB0の埋め込み次元に合わせてゼロ埋め

    # ArcFace埋め込み
    faces = app.get(img)
    arcface_embedding = faces[0].embedding if len(faces) > 0 else np.zeros(512)

    # ArcFace埋め込みに学習可能なDense層を追加
    if np.any(arcface_embedding):  # ゼロ埋めでない場合のみDense層を適用
        arcface_embedding = arcface_dense_layer(tf.convert_to_tensor(np.expand_dims(arcface_embedding, axis=0)))
        arcface_embedding = arcface_embedding.numpy().flatten()
    else:
        arcface_embedding = np.zeros(256)

    # EfficientNetB0埋め込み
    try:
        img_resized = cv2.resize(img, (224, 224))
        img_array = np.expand_dims(img_resized / 255.0, axis=0)
        efficientnet_embedding = fine_tuned_efficientnet.predict(img_array, verbose=0)
    except Exception as e:
        print(f"Warning: EfficientNetB0 embedding failed for {image_path}")
        efficientnet_embedding = np.zeros(1280)

    return arcface_embedding, efficientnet_embedding.flatten(), img

# ---------------------------------------------
# データセットの処理（埋め込みベクトルの生成）
# ---------------------------------------------
def generate_embeddings(dataset_dir, embedding_save_path):
    """
    データセットの各画像からArcFaceとEfficientNetB0の埋め込みベクトルを生成し保存する。
    """
    arcface_embeddings = []
    efficientnet_embeddings = []
    labels = []
    class_indices = {}

    total_files = sum(len(files) for _, _, files in os.walk(dataset_dir))  # 総ファイル数

    for class_idx, class_name in enumerate(sorted(os.listdir(dataset_dir))):
        class_path = os.path.join(dataset_dir, class_name)
        if not os.path.isdir(class_path):
            continue
        class_indices[class_idx] = class_name
        print(f"\nProcessing class '{class_name}'...")

        class_files = [img_name for img_name in os.listdir(class_path) if img_name.lower().endswith(('jpg', 'jpeg', 'png'))]
        no_face_count = 0

        start_time = time.time()
        for img_name in tqdm(class_files, desc=f"Class '{class_name}'", leave=True, unit="img"):
            img_path = os.path.join(class_path, img_name)
            arcface_embedding, efficientnet_embedding, img = extract_face_embeddings(img_path)
            if np.any(arcface_embedding) and np.any(efficientnet_embedding):
                arcface_embeddings.append(arcface_embedding)
                efficientnet_embeddings.append(efficientnet_embedding)
                labels.append(class_idx)
            else:
                no_face_count += 1
                save_path = os.path.join(NO_FACE_DIR, f"{class_name}_{img_name}")
                if img is not None:
                    cv2.imwrite(save_path, img)

        end_time = time.time()
        print(f"Class '{class_name}' completed in {end_time - start_time:.2f} seconds | No face detected: {no_face_count}")

    np.savez(embedding_save_path,
             arcface_embeddings=np.array(arcface_embeddings),
             efficientnet_embeddings=np.array(efficientnet_embeddings),
             labels=np.array(labels))
    print(f"Embeddings and labels saved to {embedding_save_path}")
    return class_indices

# ---------------------------------------------
# 分類モデルの構築
# ---------------------------------------------
def build_combined_model(input_dim1, input_dim2, num_classes):
    """
    ArcFaceとEfficientNetB0の埋め込みベクトルを入力とする分類モデルを構築。
    """
    input1 = Input(shape=(input_dim1,))
    input2 = Input(shape=(input_dim2,))

    # 次元を統一するDense層
    input1_projected = Dense(512, activation='relu', name="input1_projection")(input1)
    input2_projected = Dense(512, activation='relu', name="input2_projection")(input2)

    # Attention Mechanism
    attention = Attention()([input1_projected, input2_projected])
    combined = Concatenate()([input1_projected, input2_projected])
    combined_with_attention = Concatenate()([combined, attention])

    # L2正則化を追加
    x = Dense(1024, activation='relu', kernel_regularizer=l2(0.01))(combined_with_attention)
    x = Dropout(0.5)(x)
    x = Dense(512, activation='relu', kernel_regularizer=l2(0.01))(x)
    x = Dropout(0.5)(x)
    output = Dense(num_classes, activation='softmax')(x)

    model = Model(inputs=[input1, input2], outputs=output)
    model.compile(optimizer=Adam(learning_rate=0.00005),
                  loss='categorical_crossentropy',
                  metrics=['accuracy'])
    return model

# ---------------------------------------------
# メイン処理
# ---------------------------------------------
if __name__ == "__main__":
    embedding_file = os.path.join(EMBEDDING_DIR, "combined_embeddings.npz")
    class_indices = generate_embeddings(DATASET_DIR, embedding_file)

    data = np.load(embedding_file)
    X1 = data['arcface_embeddings']
    X2 = data['efficientnet_embeddings']
    y = data['labels']

    print("Building and training combined model...")
    model = build_combined_model(input_dim1=X1.shape[1], input_dim2=X2.shape[1], num_classes=len(np.unique(y)))

    # Early stopping and learning rate scheduler
    callbacks = [
        EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True),
        ReduceLROnPlateau(monitor='val_loss', factor=0.5, patience=5, min_lr=1e-6)
    ]

    class_weights = {i: len(y) / (len(np.unique(y)) * np.sum(y == i)) for i in range(len(np.unique(y)))}

    X1_train, X1_val, X2_train, X2_val, y_train, y_val = train_test_split(
        X1, X2, y, test_size=0.2, random_state=42
    )

    model.fit([X1_train, X2_train], to_categorical(y_train, num_classes=len(np.unique(y))),
              validation_data=([X1_val, X2_val], to_categorical(y_val, num_classes=len(np.unique(y)))),
              epochs=100, batch_size=32, callbacks=callbacks, class_weight=class_weights)

    model_path = os.path.join(MODEL_DIR, "combined_model_saved")
    model.save(model_path, save_format='tf')  # TensorFlow SavedModel形式で保存
    print(f"Final model saved to {model_path}")
